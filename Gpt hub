local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/DaddyFelixFucks/Lib2/refs/heads/main/Lib2", true))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/DaddyFelixFucks/ElysianTheme/refs/heads/main/Theme", true))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

print("[GPT HUB] Script starting...")

task.spawn(function()
    local success, err = pcall(function()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        char:WaitForChild("HumanoidRootPart")
        workspace:WaitForChild("Courts", 5)
        workspace:WaitForChild("Basketball", 5)
        workspace:WaitForChild("Hoop", 5)
    end)
    if not success then
        warn("[GPT HUB] Error waiting for game objects:", err)
    end
end)

_G.ShotDelay = 0.32
_G.Arc = 0
_G.YAxis = 0
_G.AimOffsetEnabled = false
_G.AimOffsetX = 0

local STATE = {
    AimbotEnabled = false,
    ArcType = "Low Arc",
    MagnetOn = false,
    MagnetRange = 25,
    SpeedOn = false,
    SpeedBoost = 0,
    AntiOOBOn = false,
    AntiTravelOn = false,
    AntiFallOn = false,
    AutoGuardOn = false,
    NearBallGuardOn = false,
    AutoDunkOn = false,
    UIVisible = true,
    ShowAutoGuardButton = false,
    DeviceSpooferOn = false,
    SelectedDevice = "PC",
    RangeIndicatorOn = false,
}

local GptHub = {}

function GptHub:findGoal()
    local closest = {nil, math.huge}
    local char = LocalPlayer.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return nil, nil end
    local myTeam = LocalPlayer.Team
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("Part") and v.Name == "Goal" and v:FindFirstChild("Swish") then
            local hoopTeam = v:FindFirstChild("Team") and v.Team.Value or nil
            if not (hoopTeam and myTeam and hoopTeam == myTeam) then
                local dist = (char.HumanoidRootPart.Position - v.Position).Magnitude
                if dist < closest[2] then closest = {v, dist} end
            end
        end
    end
    return closest[1], closest[2]
end

function GptHub:lowarc(distance)
    if distance >= 58 and distance < 59 then return 23 end
    if distance >= 59 and distance < 60 then return 27 end
    if distance >= 60 and distance < 61 then return 35 end
    if distance >= 61 and distance < 62 then return 37 end
    if distance >= 62 and distance < 63 then return 22 end
    if distance >= 63 and distance < 64 then return 26 end
    if distance >= 64 and distance < 65 then return 28 end
    if distance >= 65 and distance < 66 then return 32 end
    if distance >= 66 and distance < 67 then return 35 end
    if distance >= 67 and distance < 67.6 then return 24 end
    if distance >= 67.6 and distance < 68 then return 25 end
    if distance >= 68 and distance < 68.6 then return 26 end
    if distance >= 68.6 and distance < 69 then return 27 end
    if distance >= 69 and distance < 70 then return 30 end
    if distance >= 70 and distance < 70.6 then return 31 end
    if distance >= 70.6 and distance < 71 then return 32 end
    if distance >= 71 and distance < 72 then return 35 end
    if distance >= 72 and distance < 72.6 then return 38 end
    if distance >= 72.6 and distance <= 73 then return 39 end
    if distance < 58 then return 20 end
    if distance > 73 then return 45 end
end

function GptHub:higharc(dist)
    if dist >= 57 and dist < 60 then return 75
    elseif dist >= 60 and dist < 62 then return 70
    elseif dist >= 62 and dist < 64 then return 65
    elseif dist >= 64 and dist < 66 then return 59
    elseif dist >= 66 and dist < 68 then return 47
    elseif dist >= 68 and dist < 70 then return 70
    elseif dist >= 70 and dist < 72 then return 65
    elseif dist >= 72 and dist < 73 then return 61
    else return 0 end
end

function GptHub:velocify(target, dist)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return target end
    local velocity = char.HumanoidRootPart.Velocity
    local travelT = dist / 50
    local calc = velocity * travelT * 0.06
    return target + Vector3.new(calc.X, 0, calc.Z)
end

function GptHub:shootLow()
    local goal, distance = GptHub:findGoal()
    if not goal then return end
    if distance >= 57 and distance < 62 then LocalPlayer:SetAttribute('Power', 75)
    elseif distance >= 62 and distance < 67 then LocalPlayer:SetAttribute('Power', 80)
    elseif distance >= 67 and distance < 74 then LocalPlayer:SetAttribute('Power', 85) end
    workspace.CurrentCamera.CFrame = CFrame.new(
        LocalPlayer.Character.Head.Position,
        GptHub:velocify(goal.Position, distance) + Vector3.new(0, GptHub:lowarc(distance) + _G.Arc, 0)
    )
    local cx = workspace.CurrentCamera.ViewportSize.X / 2
    if _G.AimOffsetEnabled then cx = cx + (_G.AimOffsetX or 0) end
    local cy = workspace.CurrentCamera.ViewportSize.Y / 2 + (_G.YAxis or 0)
    local VIM = game:GetService("VirtualInputManager")
    VIM:SendMouseButtonEvent(cx, cy, 0, true, game, 0)
    VIM:SendMouseButtonEvent(cx, cy, 0, false, game, 0)
end

function GptHub:shootHigh()
    local goal, distance = GptHub:findGoal()
    if not goal then return end
    if distance >= 57 and distance < 68 then LocalPlayer:SetAttribute('Power', 80)
    elseif distance >= 68 and distance < 74 then LocalPlayer:SetAttribute('Power', 85) end
    workspace.CurrentCamera.CFrame = CFrame.new(
        LocalPlayer.Character.Head.Position,
        GptHub:velocify(goal.Position, distance) + Vector3.new(0, GptHub:higharc(distance) + _G.Arc, 0)
    )
    local cx = workspace.CurrentCamera.ViewportSize.X / 2
    if _G.AimOffsetEnabled then cx = cx + (_G.AimOffsetX or 0) end
    local cy = workspace.CurrentCamera.ViewportSize.Y / 2 + (_G.YAxis or 0)
    local VIM = game:GetService("VirtualInputManager")
    VIM:SendMouseButtonEvent(cx, cy, 0, true, game, 0)
    VIM:SendMouseButtonEvent(cx, cy, 0, false, game, 0)
end

function GptHub:shootMixed()
    if math.random() > 0.5 then GptHub:shootLow() else GptHub:shootHigh() end
end

local jumpConn
local isProcessing = false
local lastJumpTime = 0
local JUMP_COOLDOWN = 0.1

local function connectJump()
    if jumpConn then jumpConn:Disconnect() jumpConn = nil end
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid")
    jumpConn = hum.Jumping:Connect(function()
        local currentTime = tick()
        if isProcessing or (currentTime - lastJumpTime) < JUMP_COOLDOWN then return end
        if not STATE.AimbotEnabled then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if not char:FindFirstChild("Basketball") then return end
        if hrp.Velocity.Y > 2 then return end
        isProcessing = true
        lastJumpTime = currentTime
        local cam = workspace.CurrentCamera
        local oldCFrame = cam.CFrame
        local oldFOV = cam.FieldOfView
        local oldSubject = cam.CameraSubject
        task.spawn(function()
            if _G.ShotDelay and _G.ShotDelay > 0 then task.wait(_G.ShotDelay) end
            local goal, distance = GptHub:findGoal()
            if not goal then isProcessing = false return end
            local shotFired = false
            if STATE.ArcType == "Low Arc" then
                if distance >= 58 and distance <= 74 then GptHub:shootLow() shotFired = true end
            elseif STATE.ArcType == "High Arc" then
                if distance >= 57 and distance <= 74 then GptHub:shootHigh() shotFired = true end
            elseif STATE.ArcType == "Mixed Arc" then
                if distance >= 57 and distance <= 74 then GptHub:shootMixed() shotFired = true end
            end
            if shotFired then
                task.wait(0.1)
                cam.CFrame = oldCFrame
                cam.FieldOfView = oldFOV
                cam.CameraSubject = oldSubject
            end
            isProcessing = false
        end)
    end)
end

LocalPlayer.CharacterAdded:Connect(function() task.wait(1) connectJump() end)
connectJump()

local speedConn
local function applySpeed()
    if speedConn then speedConn:Disconnect() end
    if not STATE.SpeedOn then return end
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")
    speedConn = RunService.Heartbeat:Connect(function(dt)
        if not (STATE.SpeedOn and hum and hrp) then return end
        local move = hum.MoveDirection
        if move.Magnitude > 0 then
            local dir = move.Unit
            local scaled = (math.clamp(STATE.SpeedBoost, 0, 5) / 10) * 10
            hum:Move(dir, true)
            hrp.CFrame += dir * scaled * dt
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if STATE.SpeedOn then applySpeed() end
end)

local BallMagnetEnabled = false
local BallMagnetDistance = 25
local ballMagnetConnection
local BallReach = {Distance = BallMagnetDistance}
local BallMags = {Distance = BallMagnetDistance}

local function GetClosestPart(Ball)
    if not LocalPlayer.Character then return end
    local cd, cp = math.huge, nil
    for _, v in pairs(LocalPlayer.Character:GetChildren()) do
        if v:IsA("BasePart") then
            local d = (v.Position - Ball.Position).Magnitude
            if d < cd then cd = d cp = v end
        end
    end
    return cp
end

function BallMags:GetClosestBall()
    local cb, cd = nil, math.huge
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj.Name == "Basketball" and obj:FindFirstChild("Ball") then
            local Ball = obj.Ball
            local rp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if Ball and rp then
                local d = (Ball.Position - rp.Position).Magnitude
                if d < self.Distance and d < cd then cb = Ball cd = d end
            end
        end
    end
    return cb
end

function BallReach:GetClosestBall()
    local cb, cd = nil, math.huge
    for _, op in ipairs(Players:GetPlayers()) do
        local Ball = op.Character and op.Character:FindFirstChild("Basketball") and op.Character.Basketball:FindFirstChild("Ball")
        local rp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if Ball and rp then
            local d = (Ball.Position - rp.Position).Magnitude
            if d < self.Distance and d < cd then cb = Ball cd = d end
        end
    end
    return cb
end

local function toggleBallMagnet()
    if ballMagnetConnection then ballMagnetConnection:Disconnect() ballMagnetConnection = nil end
    if BallMagnetEnabled then
        ballMagnetConnection = RunService.Heartbeat:Connect(function()
            if not BallMagnetEnabled then return end
            pcall(function()
                BallReach.Distance = BallMagnetDistance
                BallMags.Distance = BallMagnetDistance
                local mb = BallMags:GetClosestBall()
                local rb = BallReach:GetClosestBall()
                local r1 = mb and GetClosestPart(mb)
                local r2 = rb and GetClosestPart(rb)
                if mb and r1 then firetouchinterest(r1, mb, 0) firetouchinterest(r1, mb, 1) end
                if rb and r2 then firetouchinterest(r2, rb, 0) firetouchinterest(r2, rb, 1) end
            end)
        end)
    end
end

local antiFallEnabled = false
local antiFallConnection = nil
local currentAntiFallBoxes = {}

local function startAntiFall()
    if antiFallConnection then return end
    antiFallConnection = task.spawn(function()
        while antiFallEnabled do
            local myChar = LocalPlayer.Character
            if not myChar then task.wait(0.1) continue end
            local myHRP = myChar:FindFirstChild("HumanoidRootPart")
            if not myHRP then task.wait(0.1) continue end
            local allPlayers = {}
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    table.insert(allPlayers, {player = plr, distance = (myHRP.Position - plr.Character.HumanoidRootPart.Position).Magnitude})
                end
            end
            table.sort(allPlayers, function(a,b) return a.distance < b.distance end)
            local closestPlayers = {}
            for i = 1, math.min(3,#allPlayers) do table.insert(closestPlayers, allPlayers[i].player) end
            for plr,_ in pairs(currentAntiFallBoxes) do
                local still = false
                for _, cp in ipairs(closestPlayers) do if plr == cp then still = true break end end
                if not still then currentAntiFallBoxes[plr]:Destroy() currentAntiFallBoxes[plr] = nil end
            end
            for _, cp in ipairs(closestPlayers) do
                if not currentAntiFallBoxes[cp] then
                    local head = cp.Character:FindFirstChild("Head")
                    if head then
                        local box = Instance.new("Part")
                        box.Name = "AntiFallBox"
                        box.Size = Vector3.new(3,3,3)
                        box.Transparency = 1
                        box.Anchored = true
                        box.CanCollide = true
                        box.Material = Enum.Material.SmoothPlastic
                        box.CFrame = head.CFrame
                        box.Parent = Workspace
                        currentAntiFallBoxes[cp] = box
                    end
                end
            end
            for plr, box in pairs(currentAntiFallBoxes) do
                if plr.Character and plr.Character:FindFirstChild("Head") then
                    box.CFrame = plr.Character.Head.CFrame
                end
            end
            task.wait(0.1)
        end
    end)
end

local function stopAntiFall()
    antiFallEnabled = false
    if antiFallConnection then task.wait(0.2) antiFallConnection = nil end
    for _, box in pairs(currentAntiFallBoxes) do box:Destroy() end
    currentAntiFallBoxes = {}
end

local function setAntiFall(on)
    antiFallEnabled = on
    if on then startAntiFall() else stopAntiFall() end
end

local AntiOOBEnabled = false
local deletedOOBs = {}
local fakeFloor

local function deleteOOB()
    deletedOOBs = {}
    local courts = Workspace:FindFirstChild("Courts")
    if courts then
        for _, court in pairs(courts:GetChildren()) do
            local oob = court:FindFirstChild("OOB")
            if oob then deletedOOBs[court] = oob:Clone() oob:Destroy() end
        end
    end
end

local function restoreOOB()
    for court, oobClone in pairs(deletedOOBs) do
        if court and court.Parent and oobClone then oobClone.Parent = court end
    end
    deletedOOBs = {}
end

local function createFakeFloor()
    if fakeFloor then return fakeFloor end
    fakeFloor = Instance.new("Part")
    fakeFloor.Size = Vector3.new(2000, 5, 1000)
    fakeFloor.Anchored = true
    fakeFloor.CanCollide = true
    fakeFloor.Transparency = 1
    fakeFloor.Position = Vector3.new(0, 49, 0)
    fakeFloor.Name = "GptHubAntiOOBFloor"
    fakeFloor.Parent = Workspace
    return fakeFloor
end

local function setAntiOOB(on)
    AntiOOBEnabled = on
    if on then deleteOOB() createFakeFloor().CanCollide = true
    else restoreOOB() if fakeFloor then fakeFloor.CanCollide = false end end
end

task.spawn(function()
    while true do
        task.wait(0.1)
        if AntiOOBEnabled then
            local courts = Workspace:FindFirstChild("Courts")
            if courts then
                for _, court in pairs(courts:GetChildren()) do
                    local oob = court:FindFirstChild("OOB")
                    if oob then oob:Destroy() end
                end
            end
            if fakeFloor then fakeFloor.CanCollide = true else createFakeFloor() end
        end
    end
end)

local cachedJumpCons = {}

local function cacheExistingJumpCons(hum)
    local list = {}
    pcall(function()
        for _, c in ipairs(getconnections(hum.Jumping)) do table.insert(list, c) end
    end)
    cachedJumpCons[hum] = list
end

local function disableCachedJumpCons(hum)
    local list = cachedJumpCons[hum]
    if not list then return end
    for _, c in ipairs(list) do pcall(function() c:Disable() end) end
end

local function enableCachedJumpCons(hum)
    local list = cachedJumpCons[hum]
    if not list then return end
    for _, c in ipairs(list) do pcall(function() c:Enable() end) end
    cachedJumpCons[hum] = nil
end

local function setAntiTravel(on)
    local char = LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    if on then cacheExistingJumpCons(hum) disableCachedJumpCons(hum) connectJump()
    else enableCachedJumpCons(hum) connectJump() end
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    local hum = (LocalPlayer.Character or {}).Humanoid
    if hum and STATE.AntiTravelOn then
        cacheExistingJumpCons(hum) disableCachedJumpCons(hum) connectJump()
    end
end)

local rangeHighlightConn = nil
local currentHighlight = nil
local lastInRange = false

local RANGE_MIN = 57
local RANGE_MAX = 73

local function applyHighlight(char, inRange)
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    if not inRange or not char then return end

    local hl = Instance.new("Highlight")
    hl.Name = "GptHubRangeHighlight"
    hl.Adornee = char
    hl.FillColor = Color3.fromRGB(0, 255, 80)
    hl.OutlineColor = Color3.fromRGB(0, 255, 80)
    hl.FillTransparency = 0.5
    hl.OutlineTransparency = 0
    hl.Parent = LocalPlayer:FindFirstChild("PlayerGui") or Workspace
    currentHighlight = hl
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    lastInRange = false
end

local function startRangeIndicator()
    if rangeHighlightConn then rangeHighlightConn:Disconnect() end
    rangeHighlightConn = RunService.Heartbeat:Connect(function()
        if not STATE.RangeIndicatorOn then
            clearHighlight()
            return
        end
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            clearHighlight()
            return
        end
        local hasBall = char:FindFirstChild("Basketball") ~= nil
        if not hasBall then
            if lastInRange then clearHighlight() end
            return
        end
        local _, distance = GptHub:findGoal()
        local inRange = distance ~= nil and distance >= RANGE_MIN and distance <= RANGE_MAX
        if inRange ~= lastInRange then
            lastInRange = inRange
            applyHighlight(char, inRange)
        end
    end)
end

local function stopRangeIndicator()
    if rangeHighlightConn then
        rangeHighlightConn:Disconnect()
        rangeHighlightConn = nil
    end
    clearHighlight()
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    clearHighlight()
    if STATE.RangeIndicatorOn then startRangeIndicator() end
end)

local autoGuardUI
local autoGuardButton
local autoGuardRunning = false
local autoGuardLoop = nil

local function getCharacter(p) return p and p.Character end
local function getBall(p) local c = getCharacter(p) return c and c:FindFirstChild("Basketball") end
local function hasBallFunc(p) return getBall(p) ~= nil end
local function getRootPart(p) local c = getCharacter(p) return c and c:FindFirstChild("HumanoidRootPart") end
local function getRootPosition(p) local rp = getRootPart(p) return rp and rp.Position end
local function getHumanoid(p) local c = getCharacter(p) return c and c:FindFirstChild("Humanoid") end

local function walkTo(target)
    local hum = getHumanoid(LocalPlayer)
    if not hum then return end
    if not target then hum:Move(Vector3.zero, false) return end
    hum:MoveTo(target)
end

local function getNearestBallHandler()
    local dist, targetPlayer = math.huge, nil
    local myRootPos = getRootPosition(LocalPlayer)
    if not myRootPos then return nil, dist end
    for _, candidate in ipairs(Players:GetPlayers()) do
        if candidate ~= LocalPlayer and hasBallFunc(candidate) then
            local pos = getRootPosition(candidate)
            if pos then
                local mag = (myRootPos - pos).Magnitude
                if mag < dist then dist = mag targetPlayer = candidate end
            end
        end
    end
    local guardRange = STATE.NearBallGuardOn and 20 or 80
    return dist <= guardRange and targetPlayer or nil, dist
end

local function startAutoGuard()
    if autoGuardRunning then return end
    autoGuardRunning = true
    autoGuardLoop = task.spawn(function()
        while STATE.AutoGuardOn do
            if hasBallFunc(LocalPlayer) then
                walkTo(nil)
            else
                local target = getNearestBallHandler()
                if target then
                    local pos = getRootPosition(target)
                    local hum2 = getHumanoid(target)
                    if pos and hum2 then walkTo(pos + (hum2.MoveDirection * 6)) end
                else walkTo(nil) end
            end
            task.wait(0.1)
        end
        walkTo(nil)
        autoGuardRunning = false
    end)
end

local function stopAutoGuard()
    STATE.AutoGuardOn = false
    walkTo(nil)
    if autoGuardLoop then task.cancel(autoGuardLoop) autoGuardLoop = nil end
    autoGuardRunning = false
end

local function updateAutoGuardButton()
    if not autoGuardButton then return end
    if STATE.AutoGuardOn then
        autoGuardButton.Text = "Disable\nAutoGuard"
        TweenService:Create(autoGuardButton, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(50, 200, 100)}):Play()
    else
        autoGuardButton.Text = "Enable\nAutoGuard"
        TweenService:Create(autoGuardButton, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(200, 50, 50)}):Play()
    end
end

local function createAutoGuardUI()
    if autoGuardUI then autoGuardUI:Destroy() end
    autoGuardUI = Instance.new("ScreenGui")
    autoGuardUI.Name = "GptHubAutoGuardUI"
    autoGuardUI.ResetOnSpawn = false
    autoGuardUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    autoGuardUI.Parent = LocalPlayer:WaitForChild("PlayerGui")

    autoGuardButton = Instance.new("TextButton")
    autoGuardButton.Size = UDim2.new(0, 120, 0, 45)
    autoGuardButton.Position = UDim2.new(0.5, 10, 0, 10)
    autoGuardButton.AnchorPoint = Vector2.new(0, 0)
    autoGuardButton.Text = "Enable\nAutoGuard"
    autoGuardButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    autoGuardButton.Font = Enum.Font.GothamBold
    autoGuardButton.TextScaled = true
    autoGuardButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    autoGuardButton.BorderSizePixel = 0
    autoGuardButton.AutoButtonColor = false
    autoGuardButton.Selectable = false
    autoGuardButton.Parent = autoGuardUI

    Instance.new("UICorner", autoGuardButton).CornerRadius = UDim.new(0, 12)

    local Stroke = Instance.new("UIStroke")
    Stroke.Thickness = 2.5
    Stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    Stroke.Parent = autoGuardButton

    local LockLabel = Instance.new("TextLabel")
    LockLabel.Size = UDim2.new(0, 18, 0, 18)
    LockLabel.Position = UDim2.new(1, -22, 0, 4)
    LockLabel.BackgroundTransparency = 1
    LockLabel.Text = "ðŸ”“"
    LockLabel.TextScaled = true
    LockLabel.ZIndex = 5
    LockLabel.Parent = autoGuardButton

    local isLocked = false
    local isDragging = false
    local agDragInput, agDragStart, agStartPos
    local inputStartTime = 0
    local didDrag = false
    local holdThreshold = 0.6

    local function setLocked(locked)
        isLocked = locked
        LockLabel.Text = locked and "ðŸ”’" or "ðŸ”“"
        TweenService:Create(autoGuardButton, TweenInfo.new(0.1), {Size = UDim2.new(0, 132, 0, 50)}):Play()
        task.wait(0.15)
        TweenService:Create(autoGuardButton, TweenInfo.new(0.1), {Size = UDim2.new(0, 120, 0, 45)}):Play()
    end

    autoGuardButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            inputStartTime = tick()
            didDrag = false
            task.delay(holdThreshold, function()
                if not didDrag then setLocked(not isLocked) end
            end)
            if not isLocked then
                isDragging = true
                agDragStart = input.Position
                agStartPos = autoGuardButton.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then isDragging = false end
                end)
            end
        end
    end)

    autoGuardButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            agDragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == agDragInput and isDragging and not isLocked then
            local delta = input.Position - agDragStart
            if delta.Magnitude > 5 then didDrag = true end
            autoGuardButton.Position = UDim2.new(agStartPos.X.Scale, agStartPos.X.Offset + delta.X, agStartPos.Y.Scale, agStartPos.Y.Offset + delta.Y)
        end
    end)

    autoGuardButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            local heldTime = tick() - inputStartTime
            isDragging = false
            if heldTime < holdThreshold and not didDrag then
                STATE.AutoGuardOn = not STATE.AutoGuardOn
                updateAutoGuardButton()
                TweenService:Create(autoGuardButton, TweenInfo.new(0.1, Enum.EasingStyle.Back), {Size = UDim2.new(0, 108, 0, 40)}):Play()
                task.wait(0.1)
                TweenService:Create(autoGuardButton, TweenInfo.new(0.15, Enum.EasingStyle.Back), {Size = UDim2.new(0, 120, 0, 45)}):Play()
                if STATE.AutoGuardOn then startAutoGuard() else stopAutoGuard() end
            end
        end
    end)

    task.spawn(function()
        while autoGuardButton and autoGuardButton.Parent do
            for i = 0, 1, 0.01 do
                if not (autoGuardButton and autoGuardButton.Parent) then break end
                pcall(function()
                    Stroke.Color = Color3.fromRGB(
                        200 + math.sin(i * math.pi * 2) * 55,
                        200 + math.cos(i * math.pi * 2) * 55,
                        255
                    )
                end)
                task.wait(0.03)
            end
        end
    end)
end

local function toggleAutoGuardUI(visible)
    if autoGuardUI then autoGuardUI.Enabled = visible
    elseif visible then createAutoGuardUI() end
end

local headSize = 50
local dunkRange = 30
local dunkSpeed = 1000
local normalHeadSize = Vector3.new(2, 1, 1)
local autoDunkEnabled = false

local function makeFakeHead(char, realHead)
    local fakeHead = char:FindFirstChild("FakeHead")
    if not fakeHead then
        fakeHead = realHead:Clone()
        fakeHead.Name = "FakeHead"
        fakeHead.Size = normalHeadSize
        fakeHead.CanCollide = false
        fakeHead.Massless = true
        fakeHead.Anchored = false
        fakeHead.Parent = char
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = realHead
        weld.Part1 = fakeHead
        weld.Parent = fakeHead
    end
    return fakeHead
end

local function updateHead(hasBall)
    local char = LocalPlayer.Character
    if not char then return end
    local head = char:FindFirstChild("Head")
    if not head then return end
    local fakeHead = makeFakeHead(char, head)
    if hasBall and autoDunkEnabled then
        head.Size = Vector3.new(headSize, headSize, headSize)
        head.Transparency = 1
        head.CanCollide = false
        head.Massless = true
        fakeHead.Size = normalHeadSize
        fakeHead.Transparency = 0
    else
        head.Size = normalHeadSize
        head.Transparency = 0
        head.CanCollide = true
        head.Massless = false
        fakeHead.Transparency = 1
    end
end

task.spawn(function()
    while true do
        task.wait(0.05)
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("Head") then continue end
        local hasBall = char:FindFirstChild("Basketball") ~= nil
        updateHead(hasBall)
        if hasBall and autoDunkEnabled then
            local head = char.Head
            local hoop = workspace:FindFirstChild("Hoop")
            if hoop and (head.Position - hoop.Position).Magnitude <= dunkRange then
                local bv = Instance.new("BodyVelocity")
                bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
                bv.Velocity = (hoop.Position - head.Position).Unit * dunkSpeed
                bv.Parent = char.Basketball
                game:GetService("Debris"):AddItem(bv, 0.1)
            end
        end
    end
end)

local ToggleGui = Instance.new("ScreenGui")
ToggleGui.Name = "GptHubToggleGui"
ToggleGui.ResetOnSpawn = false
ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local DragFrame = Instance.new("Frame")
DragFrame.Name = "DragFrame"
DragFrame.Size = UDim2.new(0, 60, 0, 70)
DragFrame.Position = UDim2.new(0, 20, 0.5, -35)
DragFrame.BackgroundTransparency = 1
DragFrame.Parent = ToggleGui

local GlowFrame = Instance.new("Frame")
GlowFrame.Size = UDim2.new(0, 56, 0, 56)
GlowFrame.Position = UDim2.new(0.5, 0, 0, 0)
GlowFrame.AnchorPoint = Vector2.new(0.5, 0)
GlowFrame.BackgroundColor3 = Color3.fromRGB(100, 80, 255)
GlowFrame.BackgroundTransparency = 0.5
GlowFrame.BorderSizePixel = 0
GlowFrame.Parent = DragFrame

Instance.new("UICorner", GlowFrame).CornerRadius = UDim.new(1, 0)

local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Size = UDim2.new(0, 46, 0, 46)
ToggleButton.Position = UDim2.new(0.5, 0, 0.5, 0)
ToggleButton.AnchorPoint = Vector2.new(0.5, 0.5)
ToggleButton.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
ToggleButton.BorderSizePixel = 0
ToggleButton.Text = ""
ToggleButton.AutoButtonColor = false
ToggleButton.ZIndex = 2
ToggleButton.Parent = GlowFrame

Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(1, 0)

local BtnStroke = Instance.new("UIStroke")
BtnStroke.Color = Color3.fromRGB(120, 100, 255)
BtnStroke.Thickness = 2
BtnStroke.Parent = ToggleButton

local LogoLabel = Instance.new("TextLabel")
LogoLabel.Size = UDim2.new(1, 0, 1, 0)
LogoLabel.BackgroundTransparency = 1
LogoLabel.Text = "G"
LogoLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
LogoLabel.Font = Enum.Font.GothamBold
LogoLabel.TextScaled = true
LogoLabel.ZIndex = 3
LogoLabel.Parent = ToggleButton

local LogoGrad = Instance.new("UIGradient")
LogoGrad.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(200, 180, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 80, 255))
}
LogoGrad.Rotation = 90
LogoGrad.Parent = LogoLabel

local MenuLabel = Instance.new("TextLabel")
MenuLabel.Size = UDim2.new(0, 60, 0, 14)
MenuLabel.Position = UDim2.new(0.5, 0, 1, 2)
MenuLabel.AnchorPoint = Vector2.new(0.5, 0)
MenuLabel.BackgroundTransparency = 1
MenuLabel.Text = "MENU"
MenuLabel.TextColor3 = Color3.fromRGB(160, 140, 255)
MenuLabel.Font = Enum.Font.GothamBold
MenuLabel.TextSize = 10
MenuLabel.Parent = DragFrame

local uiOpen = true
task.spawn(function()
    while DragFrame and DragFrame.Parent do
        for i = 0, 1, 0.02 do
            if not (DragFrame and DragFrame.Parent) then break end
            pcall(function()
                GlowFrame.BackgroundTransparency = 0.4 + math.sin(i * math.pi) * 0.3
                BtnStroke.Color = Color3.fromRGB(
                    100 + math.sin(i * math.pi * 2) * 60,
                    80 + math.cos(i * math.pi * 2) * 40,
                    255
                )
            end)
            task.wait(0.04)
        end
    end
end)

ToggleButton.MouseButton1Click:Connect(function()
    uiOpen = not uiOpen
    Library:Toggle()
    LogoLabel.Text = uiOpen and "G" or "âœ•"
    LogoLabel.TextColor3 = uiOpen and Color3.fromRGB(255,255,255) or Color3.fromRGB(255, 80, 80)
    GlowFrame.BackgroundColor3 = uiOpen and Color3.fromRGB(100, 80, 255) or Color3.fromRGB(255, 60, 60)
    TweenService:Create(ToggleButton, TweenInfo.new(0.12, Enum.EasingStyle.Back), {Size = UDim2.new(0, 38, 0, 38)}):Play()
    task.wait(0.12)
    TweenService:Create(ToggleButton, TweenInfo.new(0.18, Enum.EasingStyle.Back), {Size = UDim2.new(0, 46, 0, 46)}):Play()
end)

ToggleButton.MouseEnter:Connect(function()
    TweenService:Create(GlowFrame, TweenInfo.new(0.2), {Size = UDim2.new(0, 62, 0, 62)}):Play()
end)
ToggleButton.MouseLeave:Connect(function()
    TweenService:Create(GlowFrame, TweenInfo.new(0.2), {Size = UDim2.new(0, 56, 0, 56)}):Play()
end)

local tbDragging = false
local tbDragInput, tbDragStart, tbStartPos

DragFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        tbDragging = true
        tbDragStart = input.Position
        tbStartPos = DragFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                tbDragging = false
            end
        end)
    end
end)

DragFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        tbDragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == tbDragInput and tbDragging then
        local delta = input.Position - tbDragStart
        DragFrame.Position = UDim2.new(
            tbStartPos.X.Scale, tbStartPos.X.Offset + delta.X,
            tbStartPos.Y.Scale, tbStartPos.Y.Offset + delta.Y
        )
    end
end)

local playerGui = LocalPlayer:WaitForChild("PlayerGui", 5)
if playerGui then
    ToggleGui.Parent = playerGui
    print("[GPT HUB] Toggle UI created")
else
    warn("[GPT HUB] PlayerGui not found!")
end

local Window = Library:CreateWindow({
    Title = "gpt hub",
    Footer = "Made by 8blaq",
    Icon = 94794173630402,
    NotifySide = "Right",
    ShowCustomCursor = true,
})

local Tabs = {
    Main = Window:AddTab("Main", "target"),
    Movement = Window:AddTab("Movement", "activity"),
    Ball = Window:AddTab("Ball", "circle"),
    Misc = Window:AddTab("Misc", "settings"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local AimbotGroup = Tabs.Main:AddLeftGroupbox("Aimbot")

AimbotGroup:AddToggle("EnableAimbot", {
    Text = "Enable Aimbot",
    Default = STATE.AimbotEnabled,
    Callback = function(v) STATE.AimbotEnabled = v end,
})

AimbotGroup:AddDropdown("ArcType", {
    Text = "Arc Type",
    Default = STATE.ArcType,
    Values = {"Low Arc", "High Arc", "Mixed Arc"},
    Callback = function(v) STATE.ArcType = v end,
})

AimbotGroup:AddToggle("RangeIndicator", {
    Text = "Range Indicator",
    Default = STATE.RangeIndicatorOn,
    Callback = function(v)
        STATE.RangeIndicatorOn = v
        if v then startRangeIndicator() else stopRangeIndicator() end
    end,
})

local OffsetGroup = Tabs.Main:AddRightGroupbox("Offset Settings")

OffsetGroup:AddToggle("EnableXOffset", {
    Text = "Enable X Offset",
    Default = _G.AimOffsetEnabled,
    Callback = function(v) _G.AimOffsetEnabled = v end,
})

OffsetGroup:AddInput("XOffsetValue", {
    Text = "X Offset",
    Default = "0",
    Numeric = true,
    Finished = true,
    Placeholder = "Enter X offset",
    Callback = function(v)
        local num = tonumber(v)
        if num then _G.AimOffsetX = num end
    end,
})

OffsetGroup:AddSlider("ShotDelay", {
    Text = "Shot Delay",
    Default = _G.ShotDelay,
    Min = 0,
    Max = 0.35,
    Rounding = 2,
    Compact = false,
    Callback = function(v) _G.ShotDelay = v end,
})

local SpeedGroup = Tabs.Movement:AddLeftGroupbox("Speed")

SpeedGroup:AddToggle("EnableSpeed", {
    Text = "Enable Speed",
    Default = STATE.SpeedOn,
    Callback = function(v) STATE.SpeedOn = v applySpeed() end,
})

SpeedGroup:AddSlider("SpeedValue", {
    Text = "Speed Boost",
    Default = STATE.SpeedBoost,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(v) STATE.SpeedBoost = v end,
})

local AntiGroup = Tabs.Movement:AddRightGroupbox("Anti Features")

AntiGroup:AddToggle("AntiOOB", {
    Text = "Anti Out of Bounds",
    Default = STATE.AntiOOBOn,
    Callback = function(v) STATE.AntiOOBOn = v setAntiOOB(v) end,
})

AntiGroup:AddToggle("AntiTravel", {
    Text = "Anti Travel",
    Default = STATE.AntiTravelOn,
    Callback = function(v) STATE.AntiTravelOn = v setAntiTravel(v) end,
})

AntiGroup:AddToggle("AntiFall", {
    Text = "Anti Fall",
    Default = STATE.AntiFallOn,
    Callback = function(v) STATE.AntiFallOn = v setAntiFall(v) end,
})

local MagnetGroup = Tabs.Ball:AddLeftGroupbox("Ball Magnet")

MagnetGroup:AddToggle("EnableMagnet", {
    Text = "Enable Ball Magnet",
    Default = STATE.MagnetOn,
    Callback = function(v) BallMagnetEnabled = v STATE.MagnetOn = v toggleBallMagnet() end,
})

MagnetGroup:AddSlider("MagnetRange", {
    Text = "Magnet Range",
    Default = STATE.MagnetRange,
    Min = 0,
    Max = 150,
    Rounding = 0,
    Compact = false,
    Callback = function(v) BallMagnetDistance = v STATE.MagnetRange = v end,
})

local DunkGroup = Tabs.Ball:AddRightGroupbox("Auto Dunk")

DunkGroup:AddToggle("EnableDunk", {
    Text = "Enable Auto Dunk",
    Default = STATE.AutoDunkOn,
    Callback = function(v) autoDunkEnabled = v STATE.AutoDunkOn = v end,
})

local AutoGuardGroup = Tabs.Misc:AddLeftGroupbox("Auto Guard")

AutoGuardGroup:AddToggle("ShowAutoGuardButton", {
    Text = "Show Auto Guard Button",
    Default = STATE.ShowAutoGuardButton,
    Callback = function(v) STATE.ShowAutoGuardButton = v toggleAutoGuardUI(v) end,
})

AutoGuardGroup:AddToggle("EnableAutoGuard", {
    Text = "Enable Auto Guard",
    Default = STATE.AutoGuardOn,
    Callback = function(v)
        STATE.AutoGuardOn = v
        updateAutoGuardButton()
        if v then startAutoGuard() else stopAutoGuard() end
    end,
})

AutoGuardGroup:AddToggle("EnableNearBall", {
    Text = "Near Ball Mode",
    Default = STATE.NearBallGuardOn,
    Callback = function(v) STATE.NearBallGuardOn = v end,
})

AutoGuardGroup:AddLabel("Auto Guard Settings"):AddKeyPicker("AutoGuardKeybind", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Auto Guard Keybind",
    NoUI = false,
    Callback = function(v)
        STATE.AutoGuardOn = v
        updateAutoGuardButton()
        if v then startAutoGuard() else stopAutoGuard() end
    end,
})

local DeviceChangerGroup = Tabs.Misc:AddRightGroupbox("Device Changer")

DeviceChangerGroup:AddToggle("EnableDeviceSpoofer", {
    Text = "Enable Device Spoofer",
    Default = STATE.DeviceSpooferOn,
    Callback = function(v)
        STATE.DeviceSpooferOn = v
        if v then
            game:GetService("ReplicatedStorage").Remotes.deviceEvent:FireServer(STATE.SelectedDevice or "PC")
        end
    end,
})

DeviceChangerGroup:AddDropdown("DeviceType", {
    Text = "Device Type",
    Default = STATE.SelectedDevice,
    Values = {"PC", "Mobile"},
    Callback = function(v)
        STATE.SelectedDevice = v
        if STATE.DeviceSpooferOn then
            game:GetService("ReplicatedStorage").Remotes.deviceEvent:FireServer(v)
        end
    end,
})

local UIGroup = Tabs["UI Settings"]:AddLeftGroupbox("UI Controls")

UIGroup:AddLabel("UI Toggle Keybind"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    SyncToggleState = false,
    Mode = "Toggle",
    Text = "Menu Keybind",
    NoUI = false,
    Callback = function(v) Library:Toggle() end,
})

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
ThemeManager:SetFolder("GptHubThemes")
SaveManager:SetFolder("GptHubConfigs")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

task.spawn(function()
    task.wait(2)
    if STATE.ShowAutoGuardButton then createAutoGuardUI() end
end)

print("[GPT HUB] Loaded successfully!")
